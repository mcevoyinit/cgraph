{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CGraph - Corda & The Graph \u00b6 CGraph is a simple connector library that allows you to pipe verified data from Corda into a GraphQL server and database, over HTTP. This means you can transact across trust boundaries, with Corda for safe, secure and provable data but also, read via GraphQL for federation, flexibility, and more. Do I need this? \u00b6 Does your data model exhibit high levels of connectedness? Do you need a unified, flexible API for both reading and writing on and off-ledger data? Do you wish to work with the latest graph tooling and methodologies? e.g GraphQL, GraphDBs. Quick start \u00b6 Include the cgraph-core module as a dependency inside your build.gradle <dependency> <groupId>com.cgraph</groupId> <artifactId>cgraph</artifactId> <version>1.0-SNAPSHOT</version> </dependency>","title":"Overview"},{"location":"#cgraph-corda-the-graph","text":"CGraph is a simple connector library that allows you to pipe verified data from Corda into a GraphQL server and database, over HTTP. This means you can transact across trust boundaries, with Corda for safe, secure and provable data but also, read via GraphQL for federation, flexibility, and more.","title":"CGraph - Corda &amp; The Graph"},{"location":"#do-i-need-this","text":"Does your data model exhibit high levels of connectedness? Do you need a unified, flexible API for both reading and writing on and off-ledger data? Do you wish to work with the latest graph tooling and methodologies? e.g GraphQL, GraphDBs.","title":"Do I need this?"},{"location":"#quick-start","text":"Include the cgraph-core module as a dependency inside your build.gradle <dependency> <groupId>com.cgraph</groupId> <artifactId>cgraph</artifactId> <version>1.0-SNAPSHOT</version> </dependency>","title":"Quick start"},{"location":"faq/","text":"","title":"FAQ"},{"location":"future/","text":"","title":"Future work"},{"location":"installation/","text":"Set up your graph \u00b6 You need to specify the GraphQL server that CGraph will connect to. I chose DGraph as a first integration since the GraphQL server and KV store are in one process. However any GraphQL server should work. For each node you can either set up DGraph locally or remote. Remote \u00b6 DGraph has a free, one click deployable, instance that's super easy to get set-up over at DGraph Cloud . I use two premium (lender, borrower) instances for the demo and test. I'll add a version that works with a single instance for developer convenience in the future. Locally \u00b6 Golang set up golang and fetch binaries at DGraph Downloads $GOPATH/bin/dgraph zero $GOPATH/bin/dgraph alpha --port_offset 1 #### Docker ```docker run --rm -it -p \"8080:8080\" -p \"9080:9080\" -p \"8000:8000\" -v ~/dgraph:/dgraph \"dgraph/standalone:v21.03.0\"``` Edit the URL and Auth Token in `deployCGraph` gradle task in root `build.gradle` You can also edit the testing config in `CGraphIOUDriverTesting` to run the sample DriverDSL test. This is the URL Corda will write to and, the URL clients will read from. ### Running CGraph Hit a terminal in the project root directory: ./gradlew clean deployCGraph ./build/nodes/runnodes This brings up 3 nodes (Lender, Borrower and a Notary) You then need to connect each Nodejs client to its corresponding node cd cgraph/cgraph-js/ node.js iou-client.js 3000 8080 // new terminal tab node.js iou-client.js 3001 8081 You can interact with this HTTP API by using the Insomnia HTTP client json script CGraphInsomnia.json in the resources/scripts folder. The order in which you seed the data should go like this: Will provide mutations. Member both goes directly into their own and each other's graph. Currency written to ledger and then graph via lib. Hit node.js server over http. Balance written to ledger. References currency and holder member, from above IOU written to ledger. References all of above. IOU in both ledgers and graphs. In future versions, I'd like write a more modular architecture for extending and integrating with more graph types, for example: cgraph-cordapp cgraph-client cgraph-schema-generator cgraph-testing cgraph-sample-client cgraph-sample-cordapp","title":"Installation"},{"location":"installation/#set-up-your-graph","text":"You need to specify the GraphQL server that CGraph will connect to. I chose DGraph as a first integration since the GraphQL server and KV store are in one process. However any GraphQL server should work. For each node you can either set up DGraph locally or remote.","title":"Set up your graph"},{"location":"installation/#remote","text":"DGraph has a free, one click deployable, instance that's super easy to get set-up over at DGraph Cloud . I use two premium (lender, borrower) instances for the demo and test. I'll add a version that works with a single instance for developer convenience in the future.","title":"Remote"},{"location":"installation/#locally","text":"Golang set up golang and fetch binaries at DGraph Downloads $GOPATH/bin/dgraph zero $GOPATH/bin/dgraph alpha --port_offset 1 #### Docker ```docker run --rm -it -p \"8080:8080\" -p \"9080:9080\" -p \"8000:8000\" -v ~/dgraph:/dgraph \"dgraph/standalone:v21.03.0\"``` Edit the URL and Auth Token in `deployCGraph` gradle task in root `build.gradle` You can also edit the testing config in `CGraphIOUDriverTesting` to run the sample DriverDSL test. This is the URL Corda will write to and, the URL clients will read from. ### Running CGraph Hit a terminal in the project root directory: ./gradlew clean deployCGraph ./build/nodes/runnodes This brings up 3 nodes (Lender, Borrower and a Notary) You then need to connect each Nodejs client to its corresponding node cd cgraph/cgraph-js/ node.js iou-client.js 3000 8080 // new terminal tab node.js iou-client.js 3001 8081 You can interact with this HTTP API by using the Insomnia HTTP client json script CGraphInsomnia.json in the resources/scripts folder. The order in which you seed the data should go like this: Will provide mutations. Member both goes directly into their own and each other's graph. Currency written to ledger and then graph via lib. Hit node.js server over http. Balance written to ledger. References currency and holder member, from above IOU written to ledger. References all of above. IOU in both ledgers and graphs. In future versions, I'd like write a more modular architecture for extending and integrating with more graph types, for example: cgraph-cordapp cgraph-client cgraph-schema-generator cgraph-testing cgraph-sample-client cgraph-sample-cordapp","title":"Locally"},{"location":"why/","text":"CGraph revolves around three related topics. I list these topics as questions I\u2019ve been asking myself for over a year. Questions that I hope this piece will bring us closer to answering. Reading \u00b6 What is the optimum read model for Corda? How we get data out of the node to where it needs to be efficiently and at scale? How can we skip unnecessary steps when retrieving and viewing data? Modelling \u00b6 How do we model the overall domain of data in Corda systems? How do we unify on-ledger (state data) and off-ledger data to be queried flexibly and uniformly across the full domain of data in Corda-based systems? How can relationships be more easily modelled? How can data be traversed, extended, and developed against in the most pain-free way while maintaining compatibility with past and future versions of Corda? How can we best prepare to monetize our golden sources of data? Productivity \u00b6 How can we enable stronger cross-team collaboration around the product and data model? How can test engineers, business analysts, product owners, data engineers, and cordapp developers align further and collaborate more closely on their product and data model?","title":"The Why"},{"location":"why/#reading","text":"What is the optimum read model for Corda? How we get data out of the node to where it needs to be efficiently and at scale? How can we skip unnecessary steps when retrieving and viewing data?","title":"Reading"},{"location":"why/#modelling","text":"How do we model the overall domain of data in Corda systems? How do we unify on-ledger (state data) and off-ledger data to be queried flexibly and uniformly across the full domain of data in Corda-based systems? How can relationships be more easily modelled? How can data be traversed, extended, and developed against in the most pain-free way while maintaining compatibility with past and future versions of Corda? How can we best prepare to monetize our golden sources of data?","title":"Modelling"},{"location":"why/#productivity","text":"How can we enable stronger cross-team collaboration around the product and data model? How can test engineers, business analysts, product owners, data engineers, and cordapp developers align further and collaborate more closely on their product and data model?","title":"Productivity"},{"location":"architecture/solution/","text":"One CGraph solution architecture could take a triangular form. There are many permutations of this but here is one that may be useful to some use-cases. The Entry Point \u00b6 This NodeJS runtime is the entry point to the system for most reads and writes. Data to write is received from the user browser/client over HTTP. Then a Braid.js client and forwards the write request, again over HTTP, to an embedded Braid web server running inside Corda. I chose Braid so that its JS client could live inside a DGraph \u201cLambda\u201d server . My sense is there could be a unique synergy between DGraph Lambdas and Corda JS clients. Lambda provides a way to write your custom logic in JavaScript, integrate it with your GraphQL schema, and execute it using the GraphQL API in a few easy steps. Looking back to the flipped tiered business programming model earlier in the paper TODO, the lambda server is now layer 3 with DGraph and Corda being layer 2. A selling point of GraphQL is being able to have all the API access at a single URL. That\u2019s right, not different ports or even endpoints, but the same exact endpoint for both queries and mutations (read and writes), for everything. The GraphQL syntax defines for each HTTP request whether it is a query (default if not specified) or a mutation. It would be similar in theory to having a single SQL endpoint connection to run either SELECT statements and INSERT/UPDATE/DELETE statements. So by being able to have a custom mutation/query you can do multiple actions in a single request to a single API. The idea of arriving at a single system API endpoint for all Corda solutions, read and write is interesting. I'm currently working on this: type Mutation { invokeFlow(flowName: String!, params: Any!): ID! @lambda } These custom resolvers can be taken further. We could, for example, set up a lambda to do the following in a single mutation operation, Write an expected transaction ID in DGraph, perhaps alongside a subscription Write to Corda, which then writes to DGraph Have DGraph give us thumbs up when the expected transaction id is written, by Corda. Give user confidence that stores are consistent, in the single request This could be useful for reconciliation and logging. There is a more to it than this. Writing \u00b6 Corda flows are invoked, transactions write data to the ledger, protected by smart contracts, as normal. After the fact (more detail to be provided on guarantees here), once the data is successfully persisted, it is replicated into the Graph, over HTTP, by the CGraphService . This service currently subscribes to rawUpdates to detect GraphableStates . As mention, it then uses the CGraphMutationGenerator to generate the corresponding GraphQL mutation which is sent over HTTP by the GQLClient . Multi-state transactions resolve coherently in the graph when the correct paradigm is followed, something I\u2019ll expand on later. A two-phase commit can be used here to increase consistency, which is the main reason GraphableState would extend QueryableState . Reading \u00b6 Data enters DGraph. The same NodeJS runtime from 1. can then fetch data via GraphQL and serve data in UIs out to the browser via React. Alternatively, raw data can be queried from DGraph via GraphQL or HTTP consoles/clients. My favourite tool for this is GraphiQL Online .","title":"Architecture"},{"location":"architecture/solution/#the-entry-point","text":"This NodeJS runtime is the entry point to the system for most reads and writes. Data to write is received from the user browser/client over HTTP. Then a Braid.js client and forwards the write request, again over HTTP, to an embedded Braid web server running inside Corda. I chose Braid so that its JS client could live inside a DGraph \u201cLambda\u201d server . My sense is there could be a unique synergy between DGraph Lambdas and Corda JS clients. Lambda provides a way to write your custom logic in JavaScript, integrate it with your GraphQL schema, and execute it using the GraphQL API in a few easy steps. Looking back to the flipped tiered business programming model earlier in the paper TODO, the lambda server is now layer 3 with DGraph and Corda being layer 2. A selling point of GraphQL is being able to have all the API access at a single URL. That\u2019s right, not different ports or even endpoints, but the same exact endpoint for both queries and mutations (read and writes), for everything. The GraphQL syntax defines for each HTTP request whether it is a query (default if not specified) or a mutation. It would be similar in theory to having a single SQL endpoint connection to run either SELECT statements and INSERT/UPDATE/DELETE statements. So by being able to have a custom mutation/query you can do multiple actions in a single request to a single API. The idea of arriving at a single system API endpoint for all Corda solutions, read and write is interesting. I'm currently working on this: type Mutation { invokeFlow(flowName: String!, params: Any!): ID! @lambda } These custom resolvers can be taken further. We could, for example, set up a lambda to do the following in a single mutation operation, Write an expected transaction ID in DGraph, perhaps alongside a subscription Write to Corda, which then writes to DGraph Have DGraph give us thumbs up when the expected transaction id is written, by Corda. Give user confidence that stores are consistent, in the single request This could be useful for reconciliation and logging. There is a more to it than this.","title":"The Entry Point"},{"location":"architecture/solution/#writing","text":"Corda flows are invoked, transactions write data to the ledger, protected by smart contracts, as normal. After the fact (more detail to be provided on guarantees here), once the data is successfully persisted, it is replicated into the Graph, over HTTP, by the CGraphService . This service currently subscribes to rawUpdates to detect GraphableStates . As mention, it then uses the CGraphMutationGenerator to generate the corresponding GraphQL mutation which is sent over HTTP by the GQLClient . Multi-state transactions resolve coherently in the graph when the correct paradigm is followed, something I\u2019ll expand on later. A two-phase commit can be used here to increase consistency, which is the main reason GraphableState would extend QueryableState .","title":"Writing"},{"location":"architecture/solution/#reading","text":"Data enters DGraph. The same NodeJS runtime from 1. can then fetch data via GraphQL and serve data in UIs out to the browser via React. Alternatively, raw data can be queried from DGraph via GraphQL or HTTP consoles/clients. My favourite tool for this is GraphiQL Online .","title":"Reading"},{"location":"concepts/dgraph/","text":"DGraph is the graph technology that interests me the most. Although the CGraph Library will be architected in future to support many graph databases, I chose DGraph as a first case study run. DGraph is my personal favourite graph database. The main reasons for the decision will become clear: DGraph - \u201cDistributed Graph Database\u201d is a GraphQL native distributed graph database that is written from the disk to the top-level query interface by DGraph labs in California. DGraph is a curve jumper. It does distributed transactions, low-latency arbitrary depth joins, traversals, provides synchronous replication and horizontal scalability \u2014 with a simple GraphQL-like API - DGraph Labs Graph Native \u00b6 DGraph is unique in that it has a GraphQL server natively embedded in it, alongside its graph DB / KV store. This is interesting because: Typically the GraphQL server lives separately from the underlying datastore, as illustrated below. Having an all-in-one service greatly speeds up development effort, lowers maintenance cost, and solution complexity, which is the primary reason DGraph is CGraphs first integration. Furthermore, this removes the need for writing and maintaining a GraphQL server, resolvers, and middlewares. Maintaining a separate graph server and database processes is heavy-duty! Another example of this pairing is: Lacinia - GraphQL server written in Clojure by Walmart Labs Lacinia - GraphQL for Clojure Crux - Bitemporal Graph DB written in Clojure. Crux Pairings like the above will considered in future version. They may be better suited to larger Corda deployments. The creators of Crux have written a Crux-Corda Connector CorDapp juxt/crux-corda","title":"DGraph"},{"location":"concepts/dgraph/#graph-native","text":"DGraph is unique in that it has a GraphQL server natively embedded in it, alongside its graph DB / KV store. This is interesting because: Typically the GraphQL server lives separately from the underlying datastore, as illustrated below. Having an all-in-one service greatly speeds up development effort, lowers maintenance cost, and solution complexity, which is the primary reason DGraph is CGraphs first integration. Furthermore, this removes the need for writing and maintaining a GraphQL server, resolvers, and middlewares. Maintaining a separate graph server and database processes is heavy-duty! Another example of this pairing is: Lacinia - GraphQL server written in Clojure by Walmart Labs Lacinia - GraphQL for Clojure Crux - Bitemporal Graph DB written in Clojure. Crux Pairings like the above will considered in future version. They may be better suited to larger Corda deployments. The creators of Crux have written a Crux-Corda Connector CorDapp juxt/crux-corda","title":"Graph Native"},{"location":"concepts/domain-data/","text":"The types of data stored in Corda based organizations and systems can be put into two boxes On-ledger : highly structured, \u201crich\u201d, protected, scrupulous domain data that is operated on and invokes behaviour. Smart contract data e.g states, contracts, e-money. Off-ledger : often referred to as \u201canaemic\u201d data. This is static or reference data that is not operated on. e.g configuration data, calendars There are critiques of this categorization and the debate continues on what should be on or off the ledger. From a commercial perspective more data \u2192 more transactions \u2192 more monetization. However, putting more data on the ledger than is necessary may decrease performance, limit scaling potential, is trickier to evolve, and may decrease developer productivity, if you are not careful. Regardless of the choice, a centralized, federated knowledge graph, per node, is imperative. Corda gives us guarentees about data coming from outside the firm. The majority of roles inside the firm do not care where the data came from. They care about data federation.","title":"Domain Data"},{"location":"concepts/graph/","text":"Graphs are everywhere. \u00b6 At their core, unsurprisingly, graph technologies are built on the concept of a graph. Graphs are composed of two elements: nodes and edges. - Each node represents an entity. - Nodes/entities have properties and store objects. - Nodes are connected by links; edges. - Edges represent the relationship between two nodes. Considering that highly connected data is increasing across industries at a rapid rate, it makes sense to consider them from the perspective of Corda data models. We are already seeing cordapp data models that exhibit high levels of connectedness. Graph Query Language \u00b6 GraphQL needs little introduction. GraphQL is a query language and runtime for APIs. GraphQL is a way for clients to efficiently obtain data from servers. GraphQL provides a complete and understandable description of the data in your API. It gives clients the power to ask for exactly what they need and nothing more. It makes it easier to evolve APIs over time and enables powerful developer tools. - Offical GraphQL Graph databases \u00b6 Although databases based on graphs seem complex, they are intuitive and easy to understand. In a graph database system, relationships are stored alongside data, which means graph databases are much more performant when querying highly connected datasets. Graph databases also help to uncover insights about complex relationships within large datasets. They\u2019re particularly good at finding unapparent or indirect relationships between distantly connected data points. Graphs, above an RDMS, give\u2264 the ability to explicitly and easily connect any pieces of data together without the complexity of defining and managing foreign keys and pivot tables.","title":"The Graph"},{"location":"concepts/graph/#graphs-are-everywhere","text":"At their core, unsurprisingly, graph technologies are built on the concept of a graph. Graphs are composed of two elements: nodes and edges. - Each node represents an entity. - Nodes/entities have properties and store objects. - Nodes are connected by links; edges. - Edges represent the relationship between two nodes. Considering that highly connected data is increasing across industries at a rapid rate, it makes sense to consider them from the perspective of Corda data models. We are already seeing cordapp data models that exhibit high levels of connectedness.","title":"Graphs are everywhere."},{"location":"concepts/graph/#graph-query-language","text":"GraphQL needs little introduction. GraphQL is a query language and runtime for APIs. GraphQL is a way for clients to efficiently obtain data from servers. GraphQL provides a complete and understandable description of the data in your API. It gives clients the power to ask for exactly what they need and nothing more. It makes it easier to evolve APIs over time and enables powerful developer tools. - Offical GraphQL","title":"Graph Query Language"},{"location":"concepts/graph/#graph-databases","text":"Although databases based on graphs seem complex, they are intuitive and easy to understand. In a graph database system, relationships are stored alongside data, which means graph databases are much more performant when querying highly connected datasets. Graph databases also help to uncover insights about complex relationships within large datasets. They\u2019re particularly good at finding unapparent or indirect relationships between distantly connected data points. Graphs, above an RDMS, give\u2264 the ability to explicitly and easily connect any pieces of data together without the complexity of defining and managing foreign keys and pivot tables.","title":"Graph databases"},{"location":"concepts/productivity/","text":"From a solutions engineering perspective, we must consider the productivity of various actors in the Corda software engineering life cycle in order to increase the likelihood of project success. From a Corda perspective, we typically see an extended 4 tier business programming architecture. Many community thought leaders have sought to automate this to improve the lives of CorDapp developers. We saw this succinctly summarised in a blog post by Bond 180 Corda integration options in 2020. Classic tier qualms This paradigm frequently comes at a high cost. Even though it\u2019s Corda, the pattern we all use is more or less CRUD, which is very tedious for even basic access to simple data points. CRUD is clunky and requires special effort to give me the data I exactly want in a query. Often I just want to display what\u2019s in the database on my screen. Why do I need to write, deploy a maintain intermediate, \u201cmiddle man\u201d relay layers? Could the web service be left for custom business logic? Why does the database have to be in the bottom layer? We certainly don\u2019t want to stick DSL SQL in our client. It\u2019s not within frontend vernacular to talk to Postgres/MySQL/Vault Queries. I am constantly writing modifying and maintaining CRUD layers yet making changes in this 4 tier setup is troublesome. Stressful for backend team be \u201cone sprint ahead\u201d of other roles e.g front end, test, data engineers. Backend changes often lead to cascading breakages on other teams components. UIs break, web-server endpoints suddenly don\u2019t work, packages, like RPC clients, need to be recompiled. There\u2019s way more to it. These teams need a common data contract of reference. The question every new developer asks themselves can finally be raised again; why can\u2019t my view layer talk directly to my data layer? For that there would need to be an API in the database. Schema driven programming DGraph flips the \u00be classic tiered model around which could yield high productivity gains. Once we define the data model via the schema, DGraph can consume this and generate the CRUD API for us. This CRUD API is adjusted as the schema is adjusted. Front end and backend developers get to go to work straight away, in parallel against a common contract of reference. This alone is a key differentiator of DGraph. We move the DB from layer 3 to layer 2. One thing this means is we need a DSL that is native to browser/clients. This is where GraphQL comes in. GraphQL is the future DSL of the internet that is easy to work with and use in the browser/mobile environment. It enables us to talk to DB directly. It gets even better. From the client, we don\u2019t have to worry about knowing whether to talk to the DB or the webserver. Custom GraphQL queries and mutations, also defined on the schema, can inform the database server when to call them versus queries when to talk directly to the DB. DGraph lambdas provide Nodejs (JVM support coming this summer) to call externally. This is where we can start Corda flows over JSON RPC. The sample uses Cordite Braid at the moment but will integrate with Corda 5 embedded server. I expand on this in the solution architecture section but keep the \u201cnew\u201d layer 3 in mind.","title":"Productivity"},{"location":"cordapp/cordapps/","text":"","title":"Cordapps"},{"location":"cordapp/core/","text":"The core lib. Inside this \"CorDapp middleware\", there are various classes and services aimed to do as much work as possible for you, the user CorDapp. It contains: GraphableState \u00b6 This is the translation point for the Corda LDM and the Graph LDM. It is used solely by CGraph under the hood to perform a commit to the graph. User states should implement this, and it's member function, the buildEntityMap() function. This function returns a property map which the below service will use to generate mutations for the graph. Not all state properties need to be in here, only those needed to build a coherent mutation which aligns to the state\u2019s corresponding schema entity entry, in the graph. interface GraphableState : LinearState, QueryableState { /** * @return [MapOfMaps] representation of the implementing contract state. * This map is used by CGraph to generate mutations in order to write persisted states to the graph db instance. * Future enhances may offer more niche annotation support to better track relationships across state model and graph entities. */ fun buildEntityMap(): MapOfMaps } CGraphService \u00b6 This is the heart of CGraph. This service detects new ledger entries of type GraphableState and transforms them by passing the result of the buildEntityMap() function into the generator. Here's a snippet of the core function. private fun registerGraphableUpdatesSubscription(serviceHub: ServiceHub): Subscription { logger.debug(\"Registering CGraph Service ($nodeOrganisation) for Vault Raw Updates.\") return serviceHub.vaultService.rawUpdates.subscribe { vaultUpdate -> val graphables = vaultUpdate.produced .filter { (it.state.data is GraphableState) } .map { state -> val toGraph = (state.state.data as GraphableState) if(vaultUpdate.consumed .filter { it.state.data is GraphableState } .any { graphableInputs -> toGraph.linearId.id == (graphableInputs.state.data as GraphableState).linearId.id } ) { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.GENERAL) } else { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.ISSUANCE) } } if (graphables.isNotEmpty()) { graphables.forEach { mutation -> var request: MapOfMaps? = null try { request = performGraphQLRequest(mutation, GraphQLRequestType.MUTATION) } catch (ex: Exception) { logger.info(\"GraphQL request failed: $ex\") } finally { logger.info(\"GraphQL request success for ${request}\") } } } } } GraphQLMutationGenerator \u00b6 This class generates a mutation based on the shape of the provided state property map. There are two types of mutations supported currenty * Write mutations. These are generated for issued output GraphableState s which do not have any inputs. * Update mutations. If a GraphableState is transacted from an in input state into a new output state, this class will generate an update mutation, filtering based on the linearid, updating the old graph entry corresponding to the input state with the new fields on the output state. The generator can detect based on the presence of UUID type if a nested mutation is needed to write a separate entity. Similarly if a field is empty will setup the mutation to submit an empty entry. These mutations must conform with the schema of course. The samples should illustrates a multi state transaction being written to graph. GQLClient \u00b6 This is a vanilla GraphQL HTTP client that uses OKHttp. The above service uses this to write mutations over HTTP to the graph. At the moment, the unique id between states and graph objects is linearid. We can mark a states corresponding id entry in the schema with the @id annotation. The graph will those be idempotent to duplicate writes. Handling success and failure will come later via PersistentGraphableState","title":"The Core"},{"location":"cordapp/core/#graphablestate","text":"This is the translation point for the Corda LDM and the Graph LDM. It is used solely by CGraph under the hood to perform a commit to the graph. User states should implement this, and it's member function, the buildEntityMap() function. This function returns a property map which the below service will use to generate mutations for the graph. Not all state properties need to be in here, only those needed to build a coherent mutation which aligns to the state\u2019s corresponding schema entity entry, in the graph. interface GraphableState : LinearState, QueryableState { /** * @return [MapOfMaps] representation of the implementing contract state. * This map is used by CGraph to generate mutations in order to write persisted states to the graph db instance. * Future enhances may offer more niche annotation support to better track relationships across state model and graph entities. */ fun buildEntityMap(): MapOfMaps }","title":"GraphableState"},{"location":"cordapp/core/#cgraphservice","text":"This is the heart of CGraph. This service detects new ledger entries of type GraphableState and transforms them by passing the result of the buildEntityMap() function into the generator. Here's a snippet of the core function. private fun registerGraphableUpdatesSubscription(serviceHub: ServiceHub): Subscription { logger.debug(\"Registering CGraph Service ($nodeOrganisation) for Vault Raw Updates.\") return serviceHub.vaultService.rawUpdates.subscribe { vaultUpdate -> val graphables = vaultUpdate.produced .filter { (it.state.data is GraphableState) } .map { state -> val toGraph = (state.state.data as GraphableState) if(vaultUpdate.consumed .filter { it.state.data is GraphableState } .any { graphableInputs -> toGraph.linearId.id == (graphableInputs.state.data as GraphableState).linearId.id } ) { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.GENERAL) } else { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.ISSUANCE) } } if (graphables.isNotEmpty()) { graphables.forEach { mutation -> var request: MapOfMaps? = null try { request = performGraphQLRequest(mutation, GraphQLRequestType.MUTATION) } catch (ex: Exception) { logger.info(\"GraphQL request failed: $ex\") } finally { logger.info(\"GraphQL request success for ${request}\") } } } } }","title":"CGraphService"},{"location":"cordapp/core/#graphqlmutationgenerator","text":"This class generates a mutation based on the shape of the provided state property map. There are two types of mutations supported currenty * Write mutations. These are generated for issued output GraphableState s which do not have any inputs. * Update mutations. If a GraphableState is transacted from an in input state into a new output state, this class will generate an update mutation, filtering based on the linearid, updating the old graph entry corresponding to the input state with the new fields on the output state. The generator can detect based on the presence of UUID type if a nested mutation is needed to write a separate entity. Similarly if a field is empty will setup the mutation to submit an empty entry. These mutations must conform with the schema of course. The samples should illustrates a multi state transaction being written to graph.","title":"GraphQLMutationGenerator"},{"location":"cordapp/core/#gqlclient","text":"This is a vanilla GraphQL HTTP client that uses OKHttp. The above service uses this to write mutations over HTTP to the graph. At the moment, the unique id between states and graph objects is linearid. We can mark a states corresponding id entry in the schema with the @id annotation. The graph will those be idempotent to duplicate writes. Handling success and failure will come later via PersistentGraphableState","title":"GQLClient"},{"location":"cordapp/example/","text":"This example takes CGraph beta \u201cout for a spin\u201d consuming it as a CorDapp dependency. It extends the IOU CorDapp and making it \u201cgraphable\u201d by using the SDK. You should follow this example for inspiration on getting your own CorDapp up and running. Example CorDapp \u00b6 Data Model \u00b6 Let\u2019s consider an extended version of the classic sample IOU CordDapp data model. Even in a simple four-state data model like this, there are many relationships and ways of approaching the data model depending on the questions you want to answer. Diving in: IOU Logical Data Model \u00b6 An IOU entity represents a loan between a lender and a borrower, each of which is a Member entity. Each IOU has a unique ID, an integer value and a currency type, which is also a separate entity, Currency . Member entities also have a unique ID and a cordaNodeName of type string. We can model a bilateral or \u201cinverse\u201d relationship by also saying that each Member holds a list of the ious it has lended and borrowered. Member holds a Balance entity, inversely a Balance would have a holder Member . A Balance object exists per Currency and also, separately, an IOU can record a Currency IOU GraphQL Schema \u00b6 The entity definition. This will nearly always be a 1-1 mapping of the properties and primitive types from the GraphableState . Some entities may only exist in the graph and not as states. There are plans to create a GraphMapState where maps can be stored raw in a contract state property. Relationships between entities are marked explicitly as types in the schema. Annotations like @hasInverse(field \u201cfield_on_related_entity\u201d) allow you to mark relationships. There are many more annotations possible, which I\u2019ll expand on soon. type IOU { id: String! @id value: String! currency: Currency! lender: Member! borrower: Member! } type Member { id: String! @id cordaNodeName: String @search(by: [hash]) borrowed: [IOU] @hasInverse(field: \"borrower\") lended: [IOU] @hasInverse(field: \"lender\") balances: [Balance] @hasInverse(field: \"holder\") } type Balance { id: String! @id holder: Member, value: String currency: Currency } type Currency { id: String! @id name: String @search(by: [hash]) isoCode: String @search(by: [hash]) } State - Entity Mapping \u00b6 @BelongsToContract(IOUContract::class) data class IOUState(val value: Int, val currency: UUID, val lender: Party, val lenderMemberId: UUID, val borrower: Party, val borrowerMemberId: UUID, override val linearId: UniqueIdentifier ) : GraphableState { //** The public keys of the involved parties. *// override val participants: List<AbstractParty> get() = listOf(lender, borrower) override fun buildEntityMap(): MapOfMaps { return mapOf( \"entityType\" to \"IOU\", \"id\" to linearId.id.toString(), \"value\" to value, \"currency\" to currency, \"lender\" to lenderMemberId, \"borrower\" to borrowerMemberId ) } } Flows \u00b6 There are 4 flows in the CorDapp TODO Braid \u00b6 The example CorDapp contains a IOUBraidServer . Future enhancements may create this server for you based on GrapableFlow extensions. Testing \u00b6 E2E Integration test can be found at CGraphIOUDriverTesting @Test fun `graph enabled advanced iou cordapp e2e processing`() { driver(DriverParameters( startNodesInProcess = true, networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = emptyList()) )) { val (lender, borrower) = listOf( startNode( parameters = NodeParameters( providedName = DUMMY_LENDER_NAME, rpcUsers = listOf(user), additionalCordapps = setOf( CGraph.Cordapps.Example.withConfig( mapOf( \"braidServerPort\" to 9090 ) ), CGraph.Cordapps.Core.withConfig( mapOf( \"graphQLUrl\" to DGRAPH_URL_LENDER, \"graphQLToken\" to DGRAPH_TOKEN_LENDER, \"graphBraidServerPort\" to 8080 ) ) ) ) ), startNode( parameters = NodeParameters( providedName = DUMMY_BORROWER_NAME, rpcUsers = listOf(user), additionalCordapps = setOf( CGraph.Cordapps.Example.withConfig( mapOf( \"braidServerPort\" to 9091 ) ), CGraph.Cordapps.Core.withConfig( mapOf( \"graphQLUrl\" to DGRAPH_URL_BORROWER, \"graphQLToken\" to DGRAPH_TOKEN_BORROWER, \"graphBraidServerPort\" to 8081 ) ) ) ) ) ).map { it.getOrThrow() } val member1id = UUID.randomUUID().toString() val member2id = UUID.randomUUID().toString() val borrowerParty = borrower.nodeInfo.legalIdentities.first() println(\"Dropping data from graphs databases\") borrower.rpc.startFlowDynamic(DropGraphDataFlow::class.java) lender.rpc.startFlowDynamic(DropGraphDataFlow::class.java) println(\"Writing Members to Graph\") lender.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member1id, cordaNodeName = lender.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) lender.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member2id, cordaNodeName = borrower.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) borrower.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member2id, cordaNodeName = borrower.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) borrower.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member1id, cordaNodeName = lender.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) println(\"Writing Currency to Ledger and Graph of both parties\") lender.rpc.startFlowDynamic(IssueCurrencyFlow::class.java,\"Pound Sterling\", \"GBP\", listOf(borrowerParty)).returnValue.getOrThrow() print(\"Wait for entry to reach both lender and borrower graphs\") Thread.sleep(1000) lender.verifyCurrency(\"GBP\") borrower.verifyCurrency(\"GBP\") print(\"Issue balance into both ledgers and thus graphs\") lender.rpc.startFlowDynamic(IssueBalanceFlow::class.java,\"GBP\", 100000).returnValue.getOrThrow() borrower.rpc.startFlowDynamic(IssueBalanceFlow::class.java,\"GBP\", 0).returnValue.getOrThrow() lender.verifyBalance(\"Pound Sterling\", \"GBP\", 100000) borrower.verifyBalance(\"Pound Sterling\", \"GBP\", 0) print(\"Wait for balance entry to reach both lender and borrower graphs\") Thread.sleep(1000) print(\"Writing IOU to both ledgers and graphs, with updated balances in both also\") lender.rpc.startFlowDynamic(IssueIOUFlow::class.java, 50000, \"Pound Sterling\", borrowerParty).returnValue.getOrThrow() // Lender balance deducted. Borrower balance credited lender.verifyBalance(\"Pound Sterling\", \"GBP\", 50000) borrower.verifyBalance(\"Pound Sterling\", \"GBP\", 50000) } } Where assertions can be done by querying the vault, the graph, or both using NodeHandle extension functions. fun NodeHandle.verifyIOU(name: String, isoCode: String, value: Int) { rpc.startFlowDynamic(PostGraphQLFlow::class.java, \"\"\" query { queryBalance(filter: { value : { eq : \"$value\" } }) { currency(filter: { isoCode: { eq: \"$isoCode\" }, and : { name: { eq: \"$name\" } } } ){ id } id } } \"\"\".trimIndent(), GraphQLRequestType.QUERY ).returnValue.getOrThrow().also { assertNotNull(it, \"Currency $isoCode not present in graph\") } } `","title":"IOU Example"},{"location":"cordapp/example/#example-cordapp","text":"","title":"Example CorDapp"},{"location":"cordapp/example/#data-model","text":"Let\u2019s consider an extended version of the classic sample IOU CordDapp data model. Even in a simple four-state data model like this, there are many relationships and ways of approaching the data model depending on the questions you want to answer. Diving in:","title":"Data Model"},{"location":"cordapp/example/#iou-logical-data-model","text":"An IOU entity represents a loan between a lender and a borrower, each of which is a Member entity. Each IOU has a unique ID, an integer value and a currency type, which is also a separate entity, Currency . Member entities also have a unique ID and a cordaNodeName of type string. We can model a bilateral or \u201cinverse\u201d relationship by also saying that each Member holds a list of the ious it has lended and borrowered. Member holds a Balance entity, inversely a Balance would have a holder Member . A Balance object exists per Currency and also, separately, an IOU can record a Currency","title":"IOU Logical Data Model"},{"location":"cordapp/example/#iou-graphql-schema","text":"The entity definition. This will nearly always be a 1-1 mapping of the properties and primitive types from the GraphableState . Some entities may only exist in the graph and not as states. There are plans to create a GraphMapState where maps can be stored raw in a contract state property. Relationships between entities are marked explicitly as types in the schema. Annotations like @hasInverse(field \u201cfield_on_related_entity\u201d) allow you to mark relationships. There are many more annotations possible, which I\u2019ll expand on soon. type IOU { id: String! @id value: String! currency: Currency! lender: Member! borrower: Member! } type Member { id: String! @id cordaNodeName: String @search(by: [hash]) borrowed: [IOU] @hasInverse(field: \"borrower\") lended: [IOU] @hasInverse(field: \"lender\") balances: [Balance] @hasInverse(field: \"holder\") } type Balance { id: String! @id holder: Member, value: String currency: Currency } type Currency { id: String! @id name: String @search(by: [hash]) isoCode: String @search(by: [hash]) }","title":"IOU GraphQL Schema"},{"location":"cordapp/example/#state-entity-mapping","text":"@BelongsToContract(IOUContract::class) data class IOUState(val value: Int, val currency: UUID, val lender: Party, val lenderMemberId: UUID, val borrower: Party, val borrowerMemberId: UUID, override val linearId: UniqueIdentifier ) : GraphableState { //** The public keys of the involved parties. *// override val participants: List<AbstractParty> get() = listOf(lender, borrower) override fun buildEntityMap(): MapOfMaps { return mapOf( \"entityType\" to \"IOU\", \"id\" to linearId.id.toString(), \"value\" to value, \"currency\" to currency, \"lender\" to lenderMemberId, \"borrower\" to borrowerMemberId ) } }","title":"State - Entity Mapping"},{"location":"cordapp/example/#flows","text":"There are 4 flows in the CorDapp TODO","title":"Flows"},{"location":"cordapp/example/#braid","text":"The example CorDapp contains a IOUBraidServer . Future enhancements may create this server for you based on GrapableFlow extensions.","title":"Braid"},{"location":"cordapp/example/#testing","text":"E2E Integration test can be found at CGraphIOUDriverTesting @Test fun `graph enabled advanced iou cordapp e2e processing`() { driver(DriverParameters( startNodesInProcess = true, networkParameters = testNetworkParameters(minimumPlatformVersion = 4, notaries = emptyList()) )) { val (lender, borrower) = listOf( startNode( parameters = NodeParameters( providedName = DUMMY_LENDER_NAME, rpcUsers = listOf(user), additionalCordapps = setOf( CGraph.Cordapps.Example.withConfig( mapOf( \"braidServerPort\" to 9090 ) ), CGraph.Cordapps.Core.withConfig( mapOf( \"graphQLUrl\" to DGRAPH_URL_LENDER, \"graphQLToken\" to DGRAPH_TOKEN_LENDER, \"graphBraidServerPort\" to 8080 ) ) ) ) ), startNode( parameters = NodeParameters( providedName = DUMMY_BORROWER_NAME, rpcUsers = listOf(user), additionalCordapps = setOf( CGraph.Cordapps.Example.withConfig( mapOf( \"braidServerPort\" to 9091 ) ), CGraph.Cordapps.Core.withConfig( mapOf( \"graphQLUrl\" to DGRAPH_URL_BORROWER, \"graphQLToken\" to DGRAPH_TOKEN_BORROWER, \"graphBraidServerPort\" to 8081 ) ) ) ) ) ).map { it.getOrThrow() } val member1id = UUID.randomUUID().toString() val member2id = UUID.randomUUID().toString() val borrowerParty = borrower.nodeInfo.legalIdentities.first() println(\"Dropping data from graphs databases\") borrower.rpc.startFlowDynamic(DropGraphDataFlow::class.java) lender.rpc.startFlowDynamic(DropGraphDataFlow::class.java) println(\"Writing Members to Graph\") lender.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member1id, cordaNodeName = lender.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) lender.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member2id, cordaNodeName = borrower.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) borrower.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member2id, cordaNodeName = borrower.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) borrower.rpc.startFlowDynamic( PostGraphQLFlow::class.java, UPSERT_MEMBER_GQL( id = member1id, cordaNodeName = lender.nodeInfo.legalIdentities.first().name.graphableString() ), GraphQLRequestType.MUTATION ) println(\"Writing Currency to Ledger and Graph of both parties\") lender.rpc.startFlowDynamic(IssueCurrencyFlow::class.java,\"Pound Sterling\", \"GBP\", listOf(borrowerParty)).returnValue.getOrThrow() print(\"Wait for entry to reach both lender and borrower graphs\") Thread.sleep(1000) lender.verifyCurrency(\"GBP\") borrower.verifyCurrency(\"GBP\") print(\"Issue balance into both ledgers and thus graphs\") lender.rpc.startFlowDynamic(IssueBalanceFlow::class.java,\"GBP\", 100000).returnValue.getOrThrow() borrower.rpc.startFlowDynamic(IssueBalanceFlow::class.java,\"GBP\", 0).returnValue.getOrThrow() lender.verifyBalance(\"Pound Sterling\", \"GBP\", 100000) borrower.verifyBalance(\"Pound Sterling\", \"GBP\", 0) print(\"Wait for balance entry to reach both lender and borrower graphs\") Thread.sleep(1000) print(\"Writing IOU to both ledgers and graphs, with updated balances in both also\") lender.rpc.startFlowDynamic(IssueIOUFlow::class.java, 50000, \"Pound Sterling\", borrowerParty).returnValue.getOrThrow() // Lender balance deducted. Borrower balance credited lender.verifyBalance(\"Pound Sterling\", \"GBP\", 50000) borrower.verifyBalance(\"Pound Sterling\", \"GBP\", 50000) } } Where assertions can be done by querying the vault, the graph, or both using NodeHandle extension functions. fun NodeHandle.verifyIOU(name: String, isoCode: String, value: Int) { rpc.startFlowDynamic(PostGraphQLFlow::class.java, \"\"\" query { queryBalance(filter: { value : { eq : \"$value\" } }) { currency(filter: { isoCode: { eq: \"$isoCode\" }, and : { name: { eq: \"$name\" } } } ){ id } id } } \"\"\".trimIndent(), GraphQLRequestType.QUERY ).returnValue.getOrThrow().also { assertNotNull(it, \"Currency $isoCode not present in graph\") } } `","title":"Testing"},{"location":"cordapp/js/","text":"This is the lambda server, the braid Corda js client, among other items. The sample JS lives in here now too but future versions will seek to provide an NPM package to support user clients. We could declare flow invocation mutations in the schema. More on this in the Solution section. type Mutation { invokeFlow(flowName: String!, params: Any!): ID! @lambda }","title":"CGraph JS"},{"location":"cordapp/modules/","text":"","title":"Modules"}]}