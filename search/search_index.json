{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CGraph - Corda & The Graph \u00b6 CGraph is a simple connector library that allows you to pipe verified data from Corda into a GraphQL server and database, over HTTP. This means you can transact across trust boundaries, with Corda for safe, secure and provable data but also, read via GraphQL for federation, flexibility, and more. Do I need this? \u00b6 Does your data model exhibit high levels of connectedness? Do you need a unified, flexible API reading and writing both on and off-ledger data? Do you wish to work with the latest graph tooling and methodologies? e.g GraphQL, GraphDBs. Quick start \u00b6 Include the cgraph-core module as a dependency inside your build.gradle deploy","title":"Overview"},{"location":"#cgraph-corda-the-graph","text":"CGraph is a simple connector library that allows you to pipe verified data from Corda into a GraphQL server and database, over HTTP. This means you can transact across trust boundaries, with Corda for safe, secure and provable data but also, read via GraphQL for federation, flexibility, and more.","title":"CGraph - Corda &amp; The Graph"},{"location":"#do-i-need-this","text":"Does your data model exhibit high levels of connectedness? Do you need a unified, flexible API reading and writing both on and off-ledger data? Do you wish to work with the latest graph tooling and methodologies? e.g GraphQL, GraphDBs.","title":"Do I need this?"},{"location":"#quick-start","text":"Include the cgraph-core module as a dependency inside your build.gradle deploy","title":"Quick start"},{"location":"concepts/","text":"","title":"Concepts"},{"location":"faq/","text":"","title":"FAQ"},{"location":"future/","text":"","title":"Future work"},{"location":"installation/","text":"Set up your graph \u00b6 You need to specify the GraphQL server that CGraph will connect to. I chose DGraph as a first integration since the GraphQL server and KV store are in one process. However any GraphQL server should work. You can set up DGraph locally or remote, for each node. Remote \u00b6 DGraph has a free, one click deployable, instance that's super easy to get set-up https://cloud.dgraph.io/ . I use two premium instances for the demo and test. I'll add a version that works with a single instance for development convenience in future. Locally \u00b6 Golang binaries set up golang and fetch them at https://dgraph.io/downloads $GOPATH/bin/dgraph zero $GOPATH/bin/dgraph alpha --port_offset 1 #### Docker ```docker run --rm -it -p \"8080:8080\" -p \"9080:9080\" -p \"8000:8000\" -v ~/dgraph:/dgraph \"dgraph/standalone:v21.03.0\"``` Edit the URL and Auth Token in `deployCGraph` gradle task in root `build.gradle` You can also edit the testing config in `CGraphIOUDriverTesting` to run the sample driverdsl test. This is the URL Corda will write to and, the URL the client will read from. ### Running CGraph Hit a terminal in the project root directory: ./gradlew clean deployCGraph ./build/nodes/runnodes This brings up 3 nodes (Lender, Borrower and a Notary) You then need to connect each Nodejs client to its corresponding node cd cgraph/cgraph-js/ node.js iou-client.js 3000 8080 // new terminal tab node.js iou-client.js 3001 8081 fjsdfkj adfsadf You can interact with this HTTP API by using the Insomnia HTTP client json script CGraphInsomnia.json in the resources/scripts folder. The order in which you seed the data should go like this: Member goes directly into each nodes graph, not the ledger Currency written to ledger and then graph via lib. Hit node.js server over http. Balance written to ledger. References currency and holder member, from above IOU written to ledger. References all of above. IOU in both ledgers and graphs. In future versions, I'd like write a more modular architecture for extending and integrating with more graph types, for example: cgraph-cordapp cgraph-client cgraph-schema-generator cgraph-testing cgraph-sample-client cgraph-sample-cordapp","title":"Installation"},{"location":"installation/#set-up-your-graph","text":"You need to specify the GraphQL server that CGraph will connect to. I chose DGraph as a first integration since the GraphQL server and KV store are in one process. However any GraphQL server should work. You can set up DGraph locally or remote, for each node.","title":"Set up your graph"},{"location":"installation/#remote","text":"DGraph has a free, one click deployable, instance that's super easy to get set-up https://cloud.dgraph.io/ . I use two premium instances for the demo and test. I'll add a version that works with a single instance for development convenience in future.","title":"Remote"},{"location":"installation/#locally","text":"Golang binaries set up golang and fetch them at https://dgraph.io/downloads $GOPATH/bin/dgraph zero $GOPATH/bin/dgraph alpha --port_offset 1 #### Docker ```docker run --rm -it -p \"8080:8080\" -p \"9080:9080\" -p \"8000:8000\" -v ~/dgraph:/dgraph \"dgraph/standalone:v21.03.0\"``` Edit the URL and Auth Token in `deployCGraph` gradle task in root `build.gradle` You can also edit the testing config in `CGraphIOUDriverTesting` to run the sample driverdsl test. This is the URL Corda will write to and, the URL the client will read from. ### Running CGraph Hit a terminal in the project root directory: ./gradlew clean deployCGraph ./build/nodes/runnodes This brings up 3 nodes (Lender, Borrower and a Notary) You then need to connect each Nodejs client to its corresponding node cd cgraph/cgraph-js/ node.js iou-client.js 3000 8080 // new terminal tab node.js iou-client.js 3001 8081 fjsdfkj adfsadf You can interact with this HTTP API by using the Insomnia HTTP client json script CGraphInsomnia.json in the resources/scripts folder. The order in which you seed the data should go like this: Member goes directly into each nodes graph, not the ledger Currency written to ledger and then graph via lib. Hit node.js server over http. Balance written to ledger. References currency and holder member, from above IOU written to ledger. References all of above. IOU in both ledgers and graphs. In future versions, I'd like write a more modular architecture for extending and integrating with more graph types, for example: cgraph-cordapp cgraph-client cgraph-schema-generator cgraph-testing cgraph-sample-client cgraph-sample-cordapp","title":"Locally"},{"location":"architecture/solution/","text":"One CGraph solution architecture could take a triangular form. There are many permutations of this but here is one that may be useful to some use-cases. The Entry Point \u00b6 This NodeJS runtime is the entry point to the system for most reads and writes. Data to write is received from the user browser/client over HTTP. Then a Braid.js client and forwards the write request, again over HTTP, to an embedded Braid web server running inside Corda. I chose Braid so that its JS client could live inside a DGraph \u201cLambda\u201d server . My sense is there could be a unique synergy between DGraph Lambdas and Corda JS clients. Lambda provides a way to write your custom logic in JavaScript, integrate it with your GraphQL schema, and execute it using the GraphQL API in a few easy steps. Looking back to the flipped tiered business programming model earlier in the paper TODO, the lambda server is now layer 3 with DGraph and Corda being layer 2. A selling point of GraphQL is being able to have all the API access at a single URL. That\u2019s right, not different ports or even endpoints, but the same exact endpoint for both queries and mutations (read and writes), for everything. The GraphQL syntax defines for each HTTP request whether it is a query (default if not specified) or a mutation. It would be similar in theory to having a single SQL endpoint connection to run either SELECT statements and INSERT/UPDATE/DELETE statements. So by being able to have a custom mutation/query you can do multiple actions in a single request to a single API. The idea of arriving at a single system API endpoint for all Corda solutions, read and write is interesting. I'm currently working on this: type Mutation { invokeFlow(flowName: String!, params: Any!): ID! @lambda } These custom resolvers can be taken further. We could, for example, set up a lambda to do the following in a single mutation operation, Write an expected transaction ID in DGraph, perhaps alongside a subscription Write to Corda, which then writes to DGraph Have DGraph give us thumbs up when the expected transaction id is written, by Corda. Give user confidence that stores are consistent, in the single request This could be useful for reconciliation and logging. There is a more to it than this. Writing \u00b6 Corda flows are invoked, transactions write data to the ledger, protected by smart contracts, as normal. After the fact (more detail to be provided on guarantees here), once the data is successfully persisted, it is replicated into the Graph, over HTTP, by the CGraphService . This service currently subscribes to rawUpdates to detect GraphableStates . As mention, it then uses the CGraphMutationGenerator to generate the corresponding GraphQL mutation which is sent over HTTP by the GQLClient . Multi-state transactions resolve coherently in the graph when the correct paradigm is followed, something I\u2019ll expand on later. A two-phase commit can be used here to increase consistency, which is the main reason GraphableState would extend QueryableState . Reading \u00b6 Data enters DGraph. The same NodeJS runtime from 1. can then fetch data via GraphQL and serve data in UIs out to the browser via React. Alternatively, raw data can be queried from DGraph via GraphQL or HTTP consoles/clients. My favourite tool for this is GraphiQL Online .","title":"Architecture"},{"location":"architecture/solution/#the-entry-point","text":"This NodeJS runtime is the entry point to the system for most reads and writes. Data to write is received from the user browser/client over HTTP. Then a Braid.js client and forwards the write request, again over HTTP, to an embedded Braid web server running inside Corda. I chose Braid so that its JS client could live inside a DGraph \u201cLambda\u201d server . My sense is there could be a unique synergy between DGraph Lambdas and Corda JS clients. Lambda provides a way to write your custom logic in JavaScript, integrate it with your GraphQL schema, and execute it using the GraphQL API in a few easy steps. Looking back to the flipped tiered business programming model earlier in the paper TODO, the lambda server is now layer 3 with DGraph and Corda being layer 2. A selling point of GraphQL is being able to have all the API access at a single URL. That\u2019s right, not different ports or even endpoints, but the same exact endpoint for both queries and mutations (read and writes), for everything. The GraphQL syntax defines for each HTTP request whether it is a query (default if not specified) or a mutation. It would be similar in theory to having a single SQL endpoint connection to run either SELECT statements and INSERT/UPDATE/DELETE statements. So by being able to have a custom mutation/query you can do multiple actions in a single request to a single API. The idea of arriving at a single system API endpoint for all Corda solutions, read and write is interesting. I'm currently working on this: type Mutation { invokeFlow(flowName: String!, params: Any!): ID! @lambda } These custom resolvers can be taken further. We could, for example, set up a lambda to do the following in a single mutation operation, Write an expected transaction ID in DGraph, perhaps alongside a subscription Write to Corda, which then writes to DGraph Have DGraph give us thumbs up when the expected transaction id is written, by Corda. Give user confidence that stores are consistent, in the single request This could be useful for reconciliation and logging. There is a more to it than this.","title":"The Entry Point"},{"location":"architecture/solution/#writing","text":"Corda flows are invoked, transactions write data to the ledger, protected by smart contracts, as normal. After the fact (more detail to be provided on guarantees here), once the data is successfully persisted, it is replicated into the Graph, over HTTP, by the CGraphService . This service currently subscribes to rawUpdates to detect GraphableStates . As mention, it then uses the CGraphMutationGenerator to generate the corresponding GraphQL mutation which is sent over HTTP by the GQLClient . Multi-state transactions resolve coherently in the graph when the correct paradigm is followed, something I\u2019ll expand on later. A two-phase commit can be used here to increase consistency, which is the main reason GraphableState would extend QueryableState .","title":"Writing"},{"location":"architecture/solution/#reading","text":"Data enters DGraph. The same NodeJS runtime from 1. can then fetch data via GraphQL and serve data in UIs out to the browser via React. Alternatively, raw data can be queried from DGraph via GraphQL or HTTP consoles/clients. My favourite tool for this is GraphiQL Online .","title":"Reading"},{"location":"concepts/graph/","text":"","title":"The Graph"},{"location":"concepts/graphdb/","text":"","title":"GraphDB"},{"location":"concepts/graphql/","text":"","title":"GraphQL"},{"location":"cordapp/cordapps/","text":"","title":"Cordapps"},{"location":"cordapp/core/","text":"The core lib. Inside this \"CorDapp middleware\", there are various classes and services aimed to do as much work as possible you, the user CorDapp. It contains: GraphableState \u00b6 This is the translation point for the Corda LDM and the Graph LDM. It is used solely by CGraph under the hood to perform a commit to the graph. User states should implement this, and it's member function, the buildEntityMap() function. This function returns a property map which the below service will use to generate mutations for the graph. Not all state properties need to be in here, only those needed to build a coherent mutation which aligns to the state\u2019s corresponding schema entity entry, in the graph. interface GraphableState : LinearState, QueryableState { /** * @return [MapOfMaps] representation of the implementing contract state. * This map is used by CGraph to generate mutations in order to write persisted states to the graph db instance. * Future enhances may offer more niche annotation support to better track relationships across state model and graph entities. */ fun buildEntityMap(): MapOfMaps } CGraphService \u00b6 This is the heart of CGraph. This service detects new ledger entries of type GraphableState and transforms them by passing the result of the buildEntityMap() function into the generator. Here's a snippet of the core function. private fun registerGraphableUpdatesSubscription(serviceHub: ServiceHub): Subscription { logger.debug(\"Registering CGraph Service ($nodeOrganisation) for Vault Raw Updates.\") return serviceHub.vaultService.rawUpdates.subscribe { vaultUpdate -> val graphables = vaultUpdate.produced .filter { (it.state.data is GraphableState) } .map { state -> val toGraph = (state.state.data as GraphableState) if(vaultUpdate.consumed .filter { it.state.data is GraphableState } .any { graphableInputs -> toGraph.linearId.id == (graphableInputs.state.data as GraphableState).linearId.id } ) { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.GENERAL) } else { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.ISSUANCE) } } if (graphables.isNotEmpty()) { graphables.forEach { mutation -> var request: MapOfMaps? = null try { request = performGraphQLRequest(mutation, GraphQLRequestType.MUTATION) } catch (ex: Exception) { logger.info(\"GraphQL request failed: $ex\") } finally { logger.info(\"GraphQL request success for ${request}\") } } } } } GraphQLMutationGenerator \u00b6 This class generates a mutation based on the shape of the provided state property map. There are two types of mutations supported currenty * Write mutations. These are generated for issued output GraphableState s which do not have any inputs. * Update mutations. If a GraphableState is transacted from an in input state into a new output state, this class will generate an update mutation, filtering based on the linearid, updating the old graph entry corresponding to the input state with the new fields on the output state. The generator can detect based on the presence of UUID type if a nested mutation is needed to write a separate entity. Similarly if a field is empty will setup the mutation to submit an empty entry. These mutations must conform with the schema of course. The samples should illustrates a multi state transaction being written to graph. GQLClient \u00b6 This is a vanilla GraphQL HTTP client that uses OKHttp. The above service uses this to write mutations over HTTP to the graph. At the moment, the unique id between states and graph objects is linearid. We can mark a states corresponding id entry in the schema with the @id annotation. The graph will those be idempotent to duplicate writes. Handling success and failure will come later via PersistentGraphableState","title":"The Core"},{"location":"cordapp/core/#graphablestate","text":"This is the translation point for the Corda LDM and the Graph LDM. It is used solely by CGraph under the hood to perform a commit to the graph. User states should implement this, and it's member function, the buildEntityMap() function. This function returns a property map which the below service will use to generate mutations for the graph. Not all state properties need to be in here, only those needed to build a coherent mutation which aligns to the state\u2019s corresponding schema entity entry, in the graph. interface GraphableState : LinearState, QueryableState { /** * @return [MapOfMaps] representation of the implementing contract state. * This map is used by CGraph to generate mutations in order to write persisted states to the graph db instance. * Future enhances may offer more niche annotation support to better track relationships across state model and graph entities. */ fun buildEntityMap(): MapOfMaps }","title":"GraphableState"},{"location":"cordapp/core/#cgraphservice","text":"This is the heart of CGraph. This service detects new ledger entries of type GraphableState and transforms them by passing the result of the buildEntityMap() function into the generator. Here's a snippet of the core function. private fun registerGraphableUpdatesSubscription(serviceHub: ServiceHub): Subscription { logger.debug(\"Registering CGraph Service ($nodeOrganisation) for Vault Raw Updates.\") return serviceHub.vaultService.rawUpdates.subscribe { vaultUpdate -> val graphables = vaultUpdate.produced .filter { (it.state.data is GraphableState) } .map { state -> val toGraph = (state.state.data as GraphableState) if(vaultUpdate.consumed .filter { it.state.data is GraphableState } .any { graphableInputs -> toGraph.linearId.id == (graphableInputs.state.data as GraphableState).linearId.id } ) { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.GENERAL) } else { graphQLMutationGenerator.processStates(toGraph.buildEntityMap(), TransactionType.ISSUANCE) } } if (graphables.isNotEmpty()) { graphables.forEach { mutation -> var request: MapOfMaps? = null try { request = performGraphQLRequest(mutation, GraphQLRequestType.MUTATION) } catch (ex: Exception) { logger.info(\"GraphQL request failed: $ex\") } finally { logger.info(\"GraphQL request success for ${request}\") } } } } }","title":"CGraphService"},{"location":"cordapp/core/#graphqlmutationgenerator","text":"This class generates a mutation based on the shape of the provided state property map. There are two types of mutations supported currenty * Write mutations. These are generated for issued output GraphableState s which do not have any inputs. * Update mutations. If a GraphableState is transacted from an in input state into a new output state, this class will generate an update mutation, filtering based on the linearid, updating the old graph entry corresponding to the input state with the new fields on the output state. The generator can detect based on the presence of UUID type if a nested mutation is needed to write a separate entity. Similarly if a field is empty will setup the mutation to submit an empty entry. These mutations must conform with the schema of course. The samples should illustrates a multi state transaction being written to graph.","title":"GraphQLMutationGenerator"},{"location":"cordapp/core/#gqlclient","text":"This is a vanilla GraphQL HTTP client that uses OKHttp. The above service uses this to write mutations over HTTP to the graph. At the moment, the unique id between states and graph objects is linearid. We can mark a states corresponding id entry in the schema with the @id annotation. The graph will those be idempotent to duplicate writes. Handling success and failure will come later via PersistentGraphableState","title":"GQLClient"},{"location":"cordapp/example/","text":"This example takes CGraph beta \u201cout for a spin\u201d consuming it as a CorDapp dependency. It extends the IOU CorDapp and making it \u201cgraphable\u201d by using the SDK. You should follow this example for inspiration on getting your own CorDapp up and running. The Graphable IOU Cordapp Logical Data Model looks like:","title":"IOU Example"},{"location":"cordapp/js/","text":"This is the lambda server, the braid Corda js client, among other items. The sample JS lives in here now too but future versions will seek to provide an NPM package to support user clients.","title":"CGraph JS"},{"location":"cordapp/modules/","text":"","title":"Modules"}]}