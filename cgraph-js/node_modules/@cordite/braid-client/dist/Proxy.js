/*
 * Copyright 2018 Cordite Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';Object.defineProperty(exports, "__esModule", { value: true });exports.Proxy = exports.ServiceProxy = undefined;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};var _ServiceProxy = require('./ServiceProxy');Object.defineProperty(exports, 'ServiceProxy', { enumerable: true, get: function get() {return _interopRequireDefault(_ServiceProxy).




    default;} });var _DynamicServiceProxy = require('./DynamicServiceProxy');var _DynamicServiceProxy2 = _interopRequireDefault(_DynamicServiceProxy);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}var xhr = require('request');var

Proxy = exports.Proxy =
function Proxy(config, onOpen, onClose, onError, options) {_classCallCheck(this, Proxy);
  if (!config.url) {
    throw "config must include url property e.g. https://localhost:8080/api/jsonrpc";
  }

  if (typeof options === 'undefined') {
    options = {};
  }

  if (typeof options.strictSSL === 'undefined') {
    options.strictSSL = true;
  }

  if (!options.strictSSL) {
    if (typeof process !== 'undefined' && typeof process.env !== 'undefined') {
      // NOTE: rather nasty - to be used only in local dev for self-signed certificates
      process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
    }
  }

  var that = this;
  var errors = 0;
  var connections = 0;
  var requiredConnections = 0;

  // --- PRIVATE FUNCTIONS ---

  function onInternalOpen() {
    if (++connections === requiredConnections && errors === 0 && onOpen) {
      onOpen();
    }
  }

  function failed(msg, e) {
    e.message = msg;
    if (onError) {
      onError(e);
    } else {
      console.error(e);
    }
  }

  function onInternalClose() {
    if (--connections <= 0 && errors === 0 && onClose) {
      onClose();
    }
  }

  function onInternalError(e) {
    console.error(typeof e === 'undefined' ? 'undefined' : _typeof(e), e);
    if (++errors === 1 && onError) {
      onError(e);
    }
  }

  function bootstrap() {
    var url = config.url;
    xhr({
      method: "get",
      uri: url,
      strictSSL: options.strictSSL,
      rejectUnauthorized: !options.strictSSL,
      headers: {
        "Content-Type": "application/json" } },

    function (err, resp, body) {
      if (err) {
        clearCredentials();
        err.url = url;
        failed('failed to get services descriptor from ' + url, err);
      } else if (resp) {
        bindServices(body);
      }
    });
  }

  function bindServices(body) {
    var services = JSON.parse(body);
    var serviceNames = Object.keys(services);
    requiredConnections = serviceNames.length;
    for (var idx = 0; idx < serviceNames.length; ++idx) {
      var serviceName = serviceNames[idx];
      if (serviceName == "close") {
        console.warn('service ' + serviceName + ' uses a restricted name. this service will not be accessible');
        continue;
      }
      that[serviceName] = new _DynamicServiceProxy2.default(config, serviceName, onInternalOpen, onInternalClose, onInternalError, options);
    }
    clearCredentials();
  }

  function clearCredentials() {
    config.credentials = null;
  }

  // --- PUBLIC FUNCTIONS ---
  that.close = function () {
    for (var key in that) {
      if (that.hasOwnProperty(key) && key !== "close") {
        that[key].close();
      }
    }
  };

  // --- INITIALISATION ---
  bootstrap();
};